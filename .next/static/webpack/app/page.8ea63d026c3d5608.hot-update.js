"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/cozeService.ts":
/*!*************************************!*\
  !*** ./src/services/cozeService.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sendMessageToCoze: function() { return /* binding */ sendMessageToCoze; }\n/* harmony export */ });\n/**\r\n * cozeService.ts\r\n * Coze API服务 - 处理与Coze API的通信\r\n */ // 错误消息\nconst ERROR_MESSAGES = {\n    NETWORK: \"网络连接失败，请检查您的网络连接。\",\n    SERVER: \"服务器处理请求失败，请稍后重试。\",\n    GENERAL: \"发送消息时出现错误，请稍后重试。\",\n    STREAM: \"流式响应中断，请刷新页面重试。\",\n    API_KEY_MISSING: \"缺少API密钥，请检查环境配置。\",\n    BOT_ID_MISSING: \"缺少机器人ID，请检查环境配置。\",\n    PARAMETER_ERROR: \"API参数错误，请联系开发人员。\"\n};\n/**\r\n * 构建媒体内容为Coze API可接受的格式\r\n * @param media 媒体内容数组\r\n * @returns 转换后的Coze格式媒体内容\r\n */ const formatMediaContent = (media)=>{\n    if (!media || media.length === 0) return [];\n    return media.map((item)=>({\n            type: item.type.toLowerCase(),\n            url: item.url\n        }));\n};\n/**\r\n * 发送消息到Coze API并获取流式响应 (通过本地API代理)\r\n *\r\n * @param message 用户消息内容\r\n * @param media 媒体内容数组\r\n * @param onChunk 接收数据块的回调函数\r\n * @param onComplete 响应完成的回调函数\r\n * @returns 清理函数，用于中断请求\r\n */ const sendMessageToCoze = async function(message) {\n    let media = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], onChunk = arguments.length > 2 ? arguments[2] : void 0, onComplete = arguments.length > 3 ? arguments[3] : void 0;\n    // 创建AbortController用于中断请求\n    const controller = new AbortController();\n    const signal = controller.signal;\n    try {\n        // 构建请求体 - 使用本地API代理，适配Coze API v3\n        const requestBody = {\n            user_id: \"user_\" + Date.now(),\n            messages: [\n                {\n                    role: \"user\",\n                    content: message,\n                    // 如果有媒体内容，则添加到请求中\n                    ...media.length > 0 && {\n                        media: formatMediaContent(media)\n                    }\n                }\n            ],\n            stream: true\n        };\n        console.log(\"准备发送请求到本地API代理:\", \"/api/chat\");\n        console.log(\"请求体:\", JSON.stringify(requestBody));\n        // 发送请求到本地API代理\n        const response = await fetch(\"/api/chat\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(requestBody),\n            signal\n        });\n        console.log(\"API响应状态:\", response.status);\n        console.log(\"API响应头部:\", Object.fromEntries(response.headers.entries()));\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"API错误:\", response.status, errorText);\n            onChunk(\"服务器返回错误: \".concat(response.status));\n            if (onComplete) onComplete(); // 通知完成（出错）\n            return ()=>controller.abort();\n        }\n        // 检查响应是否支持流式传输\n        if (!response.body) {\n            console.error(\"响应不支持流式传输\");\n            onChunk(ERROR_MESSAGES.STREAM);\n            if (onComplete) onComplete(); // 通知完成（出错）\n            return ()=>controller.abort();\n        }\n        // 处理流式响应\n        const reader = response.body.getReader();\n        const decoder = new TextDecoder();\n        console.log(\"开始处理流式响应\");\n        // 记录收到的总内容（用于调试）\n        let receivedContent = \"\";\n        let hasReceivedContent = false;\n        // 异步处理流数据\n        const processStream = async ()=>{\n            try {\n                let isDone = false;\n                while(!isDone){\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        console.log(\"流式响应完成（读取器返回done）\");\n                        if (!hasReceivedContent) {\n                            console.log(\"整个响应过程中未收到任何有效内容\");\n                            onChunk(\"抱歉，服务器没有返回有效回复。\");\n                        }\n                        if (onComplete) onComplete(); // 通知前端响应已完成\n                        break;\n                    }\n                    // 解码二进制数据\n                    const chunk = decoder.decode(value, {\n                        stream: true\n                    });\n                    console.log(\"收到数据块原始内容:\", chunk);\n                    receivedContent += chunk;\n                    // 尝试不同的解析方式处理SSE格式的数据\n                    try {\n                        // 1. 首先尝试标准的SSE格式解析（data: {...} 格式）\n                        const lines = chunk.split(\"\\n\").filter((line)=>line.trim() !== \"\");\n                        let hasProcessedValidData = false;\n                        for (const line of lines){\n                            console.log(\"处理行:\", line);\n                            try {\n                                // 检查是否为SSE格式\n                                if (line.startsWith(\"data:\")) {\n                                    const jsonStr = line.substring(5).trim();\n                                    // 检查是否为[DONE]标记\n                                    if (jsonStr === \"[DONE]\") {\n                                        console.log(\"收到[DONE]标记，响应结束\");\n                                        isDone = true;\n                                        if (onComplete) onComplete(); // 通知前端响应已完成\n                                        break;\n                                    }\n                                    // 尝试解析JSON数据\n                                    try {\n                                        const data = JSON.parse(jsonStr);\n                                        console.log(\"解析到JSON数据:\", data);\n                                        // 检查是否有错误信息\n                                        if (data.status === \"failed\" && data.last_error) {\n                                            console.error(\"Coze API返回错误:\", data.last_error);\n                                            const errorMsg = data.last_error.code === 4000 ? \"\".concat(ERROR_MESSAGES.PARAMETER_ERROR, \"（错误码：\").concat(data.last_error.code, \"，信息：\").concat(data.last_error.msg, \"）\") : \"错误 \".concat(data.last_error.code, \": \").concat(data.last_error.msg);\n                                            onChunk(errorMsg);\n                                            isDone = true;\n                                            if (onComplete) onComplete();\n                                            break;\n                                        }\n                                        // 处理对话内容响应\n                                        if (data.choices && data.choices.length > 0 && data.choices[0].delta && data.choices[0].delta.content) {\n                                            // 处理官方标准格式（choices.delta.content）\n                                            onChunk(data.choices[0].delta.content);\n                                            hasReceivedContent = true;\n                                            hasProcessedValidData = true;\n                                        } else if (data.content) {\n                                            // 处理兼容格式（content字段）\n                                            onChunk(data.content);\n                                            hasReceivedContent = true;\n                                            hasProcessedValidData = true;\n                                        }\n                                        // 检查响应是否包含完成标志\n                                        if (data.done || data.choices && data.choices.length > 0 && data.choices[0].finish_reason === \"stop\") {\n                                            console.log(\"响应数据包含完成标记\");\n                                            isDone = true;\n                                            if (onComplete) onComplete(); // 通知前端响应已完成\n                                            break;\n                                        }\n                                    } catch (e) {\n                                        console.warn(\"解析JSON数据出错:\", e);\n                                    }\n                                } else if (line.trim().length > 0) {\n                                    // 如果不是data:开头但有内容，可能是直接的文本\n                                    console.log(\"收到非SSE格式数据，尝试直接处理:\", line);\n                                    // 尝试作为JSON解析\n                                    try {\n                                        const data = JSON.parse(line);\n                                        if (data.content) {\n                                            onChunk(data.content);\n                                            hasReceivedContent = true;\n                                            hasProcessedValidData = true;\n                                        }\n                                    } catch (e) {\n                                        // 不是JSON，直接作为文本内容处理\n                                        onChunk(line);\n                                        hasReceivedContent = true;\n                                        hasProcessedValidData = true;\n                                    }\n                                }\n                            } catch (e) {\n                                console.warn(\"处理行数据出错:\", e);\n                            }\n                        }\n                        // 如果没有从标准格式中提取到数据，尝试其他格式\n                        if (!hasProcessedValidData && chunk.trim().length > 0) {\n                            console.log(\"尝试处理非标准格式的整块数据\");\n                            // 3. 尝试整个数据块作为JSON\n                            try {\n                                const data = JSON.parse(chunk.trim());\n                                if (data.content) {\n                                    onChunk(data.content);\n                                    hasReceivedContent = true;\n                                }\n                                if (data.text) {\n                                    onChunk(data.text);\n                                    hasReceivedContent = true;\n                                }\n                                if (data.done) {\n                                    isDone = true;\n                                    if (onComplete) onComplete();\n                                }\n                            } catch (e) {\n                                // 4. 如果不是JSON，可能是纯文本内容\n                                if (chunk.trim().length > 0 && !chunk.includes(\"data:\")) {\n                                    console.log(\"作为纯文本内容处理\");\n                                    onChunk(chunk.trim());\n                                    hasReceivedContent = true;\n                                }\n                            }\n                        }\n                    } catch (error) {\n                        console.error(\"解析流数据块出错:\", error);\n                    }\n                }\n                // 如果流结束但没收到任何内容，发送一个默认消息\n                if (!hasReceivedContent) {\n                    console.log(\"未收到任何内容，发送默认消息\");\n                    onChunk(\"我没有收到有效的回复。请稍后再试。\");\n                }\n                // 流处理完成\n                console.log(\"流处理完成\");\n                if (onComplete) onComplete();\n            } catch (error) {\n                console.error(\"读取流出错:\", error);\n                if (error.name === \"AbortError\") {\n                    console.log(\"请求被中断\");\n                } else {\n                    console.error(\"读取流出错:\", error);\n                    onChunk(ERROR_MESSAGES.STREAM);\n                }\n                if (!hasReceivedContent) {\n                    onChunk(\"处理响应时出错，请稍后再试。\");\n                }\n                if (onComplete) onComplete(); // 通知前端响应已完成（出错）\n            }\n        };\n        // 开始处理流\n        processStream();\n        // 返回清理函数\n        return ()=>{\n            controller.abort();\n            if (onComplete) onComplete(); // 确保取消请求时也通知完成\n        };\n    } catch (error) {\n        console.error(\"请求错误:\", error);\n        if (error.name === \"AbortError\") {\n            console.log(\"请求被中断\");\n        } else {\n            onChunk(ERROR_MESSAGES.NETWORK);\n        }\n        if (onComplete) onComplete(); // 通知前端响应已完成（出错）\n        return ()=>controller.abort();\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9jb3plU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7OztDQUdDLEdBSUQsT0FBTztBQUNQLE1BQU1BLGlCQUFpQjtJQUNyQkMsU0FBUztJQUNUQyxRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsUUFBUTtJQUNSQyxpQkFBaUI7SUFDakJDLGdCQUFnQjtJQUNoQkMsaUJBQWlCO0FBQ25CO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1DLHFCQUFxQixDQUFDQztJQUMxQixJQUFJLENBQUNBLFNBQVNBLE1BQU1DLE1BQU0sS0FBSyxHQUFHLE9BQU8sRUFBRTtJQUUzQyxPQUFPRCxNQUFNRSxHQUFHLENBQUMsQ0FBQ0MsT0FBVTtZQUMxQkMsTUFBTUQsS0FBS0MsSUFBSSxDQUFDQyxXQUFXO1lBQzNCQyxLQUFLSCxLQUFLRyxHQUFHO1FBRWY7QUFDRjtBQUVBOzs7Ozs7OztDQVFDLEdBQ00sTUFBTUMsb0JBQW9CLGVBQy9CQztRQUNBUix5RUFBd0IsRUFBRSxFQUMxQlMsd0RBQ0FDO0lBRUEsMEJBQTBCO0lBQzFCLE1BQU1DLGFBQWEsSUFBSUM7SUFDdkIsTUFBTUMsU0FBU0YsV0FBV0UsTUFBTTtJQUVoQyxJQUFJO1FBQ0Ysa0NBQWtDO1FBQ2xDLE1BQU1DLGNBQWM7WUFDbEJDLFNBQVMsVUFBVUMsS0FBS0MsR0FBRztZQUMzQkMsVUFBVTtnQkFDUjtvQkFDRUMsTUFBTTtvQkFDTkMsU0FBU1o7b0JBQ1Qsa0JBQWtCO29CQUNsQixHQUFJUixNQUFNQyxNQUFNLEdBQUcsS0FBSzt3QkFBRUQsT0FBT0QsbUJBQW1CQztvQkFBTyxDQUFDO2dCQUM5RDthQUNEO1lBQ0RxQixRQUFRO1FBQ1Y7UUFFQUMsUUFBUUMsR0FBRyxDQUFDLG1CQUFtQjtRQUMvQkQsUUFBUUMsR0FBRyxDQUFDLFFBQVFDLEtBQUtDLFNBQVMsQ0FBQ1g7UUFFbkMsZUFBZTtRQUNmLE1BQU1ZLFdBQVcsTUFBTUMsTUFBTSxhQUFhO1lBQ3hD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cyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9jb3plU2VydmljZS50cz81ZjFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBjb3plU2VydmljZS50c1xyXG4gKiBDb3plIEFQSeacjeWKoSAtIOWkhOeQhuS4jkNvemUgQVBJ55qE6YCa5L+hXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgTWVkaWFDb250ZW50LCBMTE1SZXNwb25zZSB9IGZyb20gXCJAL3R5cGVzL2NoYXRcIjtcclxuXHJcbi8vIOmUmeivr+a2iOaBr1xyXG5jb25zdCBFUlJPUl9NRVNTQUdFUyA9IHtcclxuICBORVRXT1JLOiBcIue9kee7nOi/nuaOpeWksei0pe+8jOivt+ajgOafpeaCqOeahOe9kee7nOi/nuaOpeOAglwiLFxyXG4gIFNFUlZFUjogXCLmnI3liqHlmajlpITnkIbor7fmsYLlpLHotKXvvIzor7fnqI3lkI7ph43or5XjgIJcIixcclxuICBHRU5FUkFMOiBcIuWPkemAgea2iOaBr+aXtuWHuueOsOmUmeivr++8jOivt+eojeWQjumHjeivleOAglwiLFxyXG4gIFNUUkVBTTogXCLmtYHlvI/lk43lupTkuK3mlq3vvIzor7fliLfmlrDpobXpnaLph43or5XjgIJcIixcclxuICBBUElfS0VZX01JU1NJTkc6IFwi57y65bCRQVBJ5a+G6ZKl77yM6K+35qOA5p+l546v5aKD6YWN572u44CCXCIsXHJcbiAgQk9UX0lEX01JU1NJTkc6IFwi57y65bCR5py65Zmo5Lq6SUTvvIzor7fmo4Dmn6Xnjq/looPphY3nva7jgIJcIixcclxuICBQQVJBTUVURVJfRVJST1I6IFwiQVBJ5Y+C5pWw6ZSZ6K+v77yM6K+36IGU57O75byA5Y+R5Lq65ZGY44CCXCIsXHJcbn07XHJcblxyXG4vKipcclxuICog5p6E5bu65aqS5L2T5YaF5a655Li6Q296ZSBBUEnlj6/mjqXlj5fnmoTmoLzlvI9cclxuICogQHBhcmFtIG1lZGlhIOWqkuS9k+WGheWuueaVsOe7hFxyXG4gKiBAcmV0dXJucyDovazmjaLlkI7nmoRDb3pl5qC85byP5aqS5L2T5YaF5a65XHJcbiAqL1xyXG5jb25zdCBmb3JtYXRNZWRpYUNvbnRlbnQgPSAobWVkaWE6IE1lZGlhQ29udGVudFtdKSA9PiB7XHJcbiAgaWYgKCFtZWRpYSB8fCBtZWRpYS5sZW5ndGggPT09IDApIHJldHVybiBbXTtcclxuXHJcbiAgcmV0dXJuIG1lZGlhLm1hcCgoaXRlbSkgPT4gKHtcclxuICAgIHR5cGU6IGl0ZW0udHlwZS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgdXJsOiBpdGVtLnVybCxcclxuICAgIC8vIOagueaNrkNvemUgQVBJ55qE6KaB5rGC5Y+v6IO96ZyA6KaB5re75Yqg5YW25LuW5a2X5q61XHJcbiAgfSkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIOWPkemAgea2iOaBr+WIsENvemUgQVBJ5bm26I635Y+W5rWB5byP5ZON5bqUICjpgJrov4fmnKzlnLBBUEnku6PnkIYpXHJcbiAqXHJcbiAqIEBwYXJhbSBtZXNzYWdlIOeUqOaIt+a2iOaBr+WGheWuuVxyXG4gKiBAcGFyYW0gbWVkaWEg5aqS5L2T5YaF5a655pWw57uEXHJcbiAqIEBwYXJhbSBvbkNodW5rIOaOpeaUtuaVsOaNruWdl+eahOWbnuiwg+WHveaVsFxyXG4gKiBAcGFyYW0gb25Db21wbGV0ZSDlk43lupTlrozmiJDnmoTlm57osIPlh73mlbBcclxuICogQHJldHVybnMg5riF55CG5Ye95pWw77yM55So5LqO5Lit5pat6K+35rGCXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2VuZE1lc3NhZ2VUb0NvemUgPSBhc3luYyAoXHJcbiAgbWVzc2FnZTogc3RyaW5nLFxyXG4gIG1lZGlhOiBNZWRpYUNvbnRlbnRbXSA9IFtdLFxyXG4gIG9uQ2h1bms6IChjaHVuazogc3RyaW5nKSA9PiB2b2lkLFxyXG4gIG9uQ29tcGxldGU/OiAoKSA9PiB2b2lkXHJcbik6IFByb21pc2U8KCkgPT4gdm9pZD4gPT4ge1xyXG4gIC8vIOWIm+W7ukFib3J0Q29udHJvbGxlcueUqOS6juS4reaWreivt+axglxyXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgY29uc3Qgc2lnbmFsID0gY29udHJvbGxlci5zaWduYWw7XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyDmnoTlu7ror7fmsYLkvZMgLSDkvb/nlKjmnKzlnLBBUEnku6PnkIbvvIzpgILphY1Db3plIEFQSSB2M1xyXG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XHJcbiAgICAgIHVzZXJfaWQ6IFwidXNlcl9cIiArIERhdGUubm93KCksIC8vIOeUn+aIkOS4gOS4quWUr+S4gOeahOeUqOaIt0lEXHJcbiAgICAgIG1lc3NhZ2VzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXHJcbiAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLFxyXG4gICAgICAgICAgLy8g5aaC5p6c5pyJ5aqS5L2T5YaF5a6577yM5YiZ5re75Yqg5Yiw6K+35rGC5LitXHJcbiAgICAgICAgICAuLi4obWVkaWEubGVuZ3RoID4gMCAmJiB7IG1lZGlhOiBmb3JtYXRNZWRpYUNvbnRlbnQobWVkaWEpIH0pLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIHN0cmVhbTogdHJ1ZSwgLy8g5ZCv55So5rWB5byP5ZON5bqUXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwi5YeG5aSH5Y+R6YCB6K+35rGC5Yiw5pys5ZywQVBJ5Luj55CGOlwiLCBcIi9hcGkvY2hhdFwiKTtcclxuICAgIGNvbnNvbGUubG9nKFwi6K+35rGC5L2TOlwiLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSkpO1xyXG5cclxuICAgIC8vIOWPkemAgeivt+axguWIsOacrOWcsEFQSeS7o+eQhlxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvY2hhdFwiLCB7XHJcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxyXG4gICAgICBzaWduYWwsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIkFQSeWTjeW6lOeKtuaAgTpcIiwgcmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgIGNvbnNvbGUubG9nKFwiQVBJ5ZON5bqU5aS06YOoOlwiLCBPYmplY3QuZnJvbUVudHJpZXMocmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpKTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkFQSemUmeivrzpcIiwgcmVzcG9uc2Uuc3RhdHVzLCBlcnJvclRleHQpO1xyXG4gICAgICBvbkNodW5rKGDmnI3liqHlmajov5Tlm57plJnor686ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgICBpZiAob25Db21wbGV0ZSkgb25Db21wbGV0ZSgpOyAvLyDpgJrnn6XlrozmiJDvvIjlh7rplJnvvIlcclxuICAgICAgcmV0dXJuICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDmo4Dmn6Xlk43lupTmmK/lkKbmlK/mjIHmtYHlvI/kvKDovpNcclxuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwi5ZON5bqU5LiN5pSv5oyB5rWB5byP5Lyg6L6TXCIpO1xyXG4gICAgICBvbkNodW5rKEVSUk9SX01FU1NBR0VTLlNUUkVBTSk7XHJcbiAgICAgIGlmIChvbkNvbXBsZXRlKSBvbkNvbXBsZXRlKCk7IC8vIOmAmuefpeWujOaIkO+8iOWHuumUme+8iVxyXG4gICAgICByZXR1cm4gKCkgPT4gY29udHJvbGxlci5hYm9ydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOWkhOeQhua1geW8j+WTjeW6lFxyXG4gICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcclxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIuW8gOWni+WkhOeQhua1geW8j+WTjeW6lFwiKTtcclxuXHJcbiAgICAvLyDorrDlvZXmlLbliLDnmoTmgLvlhoXlrrnvvIjnlKjkuo7osIPor5XvvIlcclxuICAgIGxldCByZWNlaXZlZENvbnRlbnQgPSBcIlwiO1xyXG4gICAgbGV0IGhhc1JlY2VpdmVkQ29udGVudCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIOW8guatpeWkhOeQhua1geaVsOaNrlxyXG4gICAgY29uc3QgcHJvY2Vzc1N0cmVhbSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgaXNEb25lID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHdoaWxlICghaXNEb25lKSB7XHJcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xyXG5cclxuICAgICAgICAgIGlmIChkb25lKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5rWB5byP5ZON5bqU5a6M5oiQ77yI6K+75Y+W5Zmo6L+U5ZueZG9uZe+8iVwiKTtcclxuICAgICAgICAgICAgaWYgKCFoYXNSZWNlaXZlZENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuaVtOS4quWTjeW6lOi/h+eoi+S4reacquaUtuWIsOS7u+S9leacieaViOWGheWuuVwiKTtcclxuICAgICAgICAgICAgICBvbkNodW5rKFwi5oqx5q2J77yM5pyN5Yqh5Zmo5rKh5pyJ6L+U5Zue5pyJ5pWI5Zue5aSN44CCXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSBvbkNvbXBsZXRlKCk7IC8vIOmAmuefpeWJjeerr+WTjeW6lOW3suWujOaIkFxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyDop6PnoIHkuozov5vliLbmlbDmja5cclxuICAgICAgICAgIGNvbnN0IGNodW5rID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCLmlLbliLDmlbDmja7lnZfljp/lp4vlhoXlrrk6XCIsIGNodW5rKTtcclxuICAgICAgICAgIHJlY2VpdmVkQ29udGVudCArPSBjaHVuaztcclxuXHJcbiAgICAgICAgICAvLyDlsJ3or5XkuI3lkIznmoTop6PmnpDmlrnlvI/lpITnkIZTU0XmoLzlvI/nmoTmlbDmja5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIDEuIOmmluWFiOWwneivleagh+WHhueahFNTReagvOW8j+ino+aekO+8iGRhdGE6IHsuLi59IOagvOW8j++8iVxyXG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGNodW5rXHJcbiAgICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXHJcbiAgICAgICAgICAgICAgLmZpbHRlcigobGluZSkgPT4gbGluZS50cmltKCkgIT09IFwiXCIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGhhc1Byb2Nlc3NlZFZhbGlkRGF0YSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLlpITnkIbooYw6XCIsIGxpbmUpO1xyXG5cclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8g5qOA5p+l5piv5ZCm5Li6U1NF5qC85byPXHJcbiAgICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QganNvblN0ciA9IGxpbmUuc3Vic3RyaW5nKDUpLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIOajgOafpeaYr+WQpuS4ultET05FXeagh+iusFxyXG4gICAgICAgICAgICAgICAgICBpZiAoanNvblN0ciA9PT0gXCJbRE9ORV1cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5pS25YiwW0RPTkVd5qCH6K6w77yM5ZON5bqU57uT5p2fXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uQ29tcGxldGUpIG9uQ29tcGxldGUoKTsgLy8g6YCa55+l5YmN56uv5ZON5bqU5bey5a6M5oiQXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIOWwneivleino+aekEpTT07mlbDmja5cclxuICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uU3RyKSBhcyBMTE1SZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuino+aekOWIsEpTT07mlbDmja46XCIsIGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyDmo4Dmn6XmmK/lkKbmnInplJnor6/kv6Hmga9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09IFwiZmFpbGVkXCIgJiYgZGF0YS5sYXN0X2Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ296ZSBBUEnov5Tlm57plJnor686XCIsIGRhdGEubGFzdF9lcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEubGFzdF9lcnJvci5jb2RlID09PSA0MDAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtFUlJPUl9NRVNTQUdFUy5QQVJBTUVURVJfRVJST1J977yI6ZSZ6K+v56CB77yaJHtkYXRhLmxhc3RfZXJyb3IuY29kZX3vvIzkv6Hmga/vvJoke2RhdGEubGFzdF9lcnJvci5tc2d977yJYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogYOmUmeivryAke2RhdGEubGFzdF9lcnJvci5jb2RlfTogJHtkYXRhLmxhc3RfZXJyb3IubXNnfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICBvbkNodW5rKGVycm9yTXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlzRG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob25Db21wbGV0ZSkgb25Db21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyDlpITnkIblr7nor53lhoXlrrnlk43lupRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNob2ljZXMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2hvaWNlcy5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNob2ljZXNbMF0uZGVsdGEgJiZcclxuICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2hvaWNlc1swXS5kZWx0YS5jb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyDlpITnkIblrpjmlrnmoIflh4bmoLzlvI/vvIhjaG9pY2VzLmRlbHRhLmNvbnRlbnTvvIlcclxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2h1bmsoZGF0YS5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaGFzUmVjZWl2ZWRDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgIGhhc1Byb2Nlc3NlZFZhbGlkRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIOWkhOeQhuWFvOWuueagvOW8j++8iGNvbnRlbnTlrZfmrrXvvIlcclxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2h1bmsoZGF0YS5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgIGhhc1JlY2VpdmVkQ29udGVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9jZXNzZWRWYWxpZERhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5qOA5p+l5ZON5bqU5piv5ZCm5YyF5ZCr5a6M5oiQ5qCH5b+XXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YS5kb25lIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAoZGF0YS5jaG9pY2VzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2hvaWNlcy5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2hvaWNlc1swXS5maW5pc2hfcmVhc29uID09PSBcInN0b3BcIilcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5ZON5bqU5pWw5o2u5YyF5ZCr5a6M5oiQ5qCH6K6wXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSBvbkNvbXBsZXRlKCk7IC8vIOmAmuefpeWJjeerr+WTjeW6lOW3suWujOaIkFxyXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwi6Kej5p6QSlNPTuaVsOaNruWHuumUmTpcIiwgZSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIDIuIOWwneivleino+aekOmdnuagh+WHhuagvOW8j++8iOWPr+iDveaYr+ebtOaOpeeahOaWh+acrOWGheWuue+8iVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGluZS50cmltKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAvLyDlpoLmnpzkuI3mmK9kYXRhOuW8gOWktOS9huacieWGheWuue+8jOWPr+iDveaYr+ebtOaOpeeahOaWh+acrFxyXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuaUtuWIsOmdnlNTReagvOW8j+aVsOaNru+8jOWwneivleebtOaOpeWkhOeQhjpcIiwgbGluZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyDlsJ3or5XkvZzkuLpKU09O6Kej5p6QXHJcbiAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UobGluZSkgYXMgYW55O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2h1bmsoZGF0YS5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgIGhhc1JlY2VpdmVkQ29udGVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9jZXNzZWRWYWxpZERhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOS4jeaYr0pTT07vvIznm7TmjqXkvZzkuLrmlofmnKzlhoXlrrnlpITnkIZcclxuICAgICAgICAgICAgICAgICAgICBvbkNodW5rKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1JlY2VpdmVkQ29udGVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzUHJvY2Vzc2VkVmFsaWREYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIuWkhOeQhuihjOaVsOaNruWHuumUmTpcIiwgZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyDlpoLmnpzmsqHmnInku47moIflh4bmoLzlvI/kuK3mj5Dlj5bliLDmlbDmja7vvIzlsJ3or5Xlhbbku5bmoLzlvI9cclxuICAgICAgICAgICAgaWYgKCFoYXNQcm9jZXNzZWRWYWxpZERhdGEgJiYgY2h1bmsudHJpbSgpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuWwneivleWkhOeQhumdnuagh+WHhuagvOW8j+eahOaVtOWdl+aVsOaNrlwiKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMy4g5bCd6K+V5pW05Liq5pWw5o2u5Z2X5L2c5Li6SlNPTlxyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShjaHVuay50cmltKCkpIGFzIGFueTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgb25DaHVuayhkYXRhLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgICBoYXNSZWNlaXZlZENvbnRlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEudGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICBvbkNodW5rKGRhdGEudGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgIGhhc1JlY2VpdmVkQ29udGVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlzRG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSBvbkNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gNC4g5aaC5p6c5LiN5pivSlNPTu+8jOWPr+iDveaYr+e6r+aWh+acrOWGheWuuVxyXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLnRyaW0oKS5sZW5ndGggPiAwICYmICFjaHVuay5pbmNsdWRlcyhcImRhdGE6XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5L2c5Li657qv5paH5pys5YaF5a655aSE55CGXCIpO1xyXG4gICAgICAgICAgICAgICAgICBvbkNodW5rKGNodW5rLnRyaW0oKSk7XHJcbiAgICAgICAgICAgICAgICAgIGhhc1JlY2VpdmVkQ29udGVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwi6Kej5p6Q5rWB5pWw5o2u5Z2X5Ye66ZSZOlwiLCBlcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDlpoLmnpzmtYHnu5PmnZ/kvYbmsqHmlLbliLDku7vkvZXlhoXlrrnvvIzlj5HpgIHkuIDkuKrpu5jorqTmtojmga9cclxuICAgICAgICBpZiAoIWhhc1JlY2VpdmVkQ29udGVudCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCLmnKrmlLbliLDku7vkvZXlhoXlrrnvvIzlj5HpgIHpu5jorqTmtojmga9cIik7XHJcbiAgICAgICAgICBvbkNodW5rKFwi5oiR5rKh5pyJ5pS25Yiw5pyJ5pWI55qE5Zue5aSN44CC6K+356iN5ZCO5YaN6K+V44CCXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5rWB5aSE55CG5a6M5oiQXHJcbiAgICAgICAgY29uc29sZS5sb2coXCLmtYHlpITnkIblrozmiJBcIik7XHJcbiAgICAgICAgaWYgKG9uQ29tcGxldGUpIG9uQ29tcGxldGUoKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwi6K+75Y+W5rWB5Ye66ZSZOlwiLCBlcnJvcik7XHJcblxyXG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCLor7fmsYLooqvkuK3mlq1cIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLor7vlj5bmtYHlh7rplJk6XCIsIGVycm9yKTtcclxuICAgICAgICAgIG9uQ2h1bmsoRVJST1JfTUVTU0FHRVMuU1RSRUFNKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaGFzUmVjZWl2ZWRDb250ZW50KSB7XHJcbiAgICAgICAgICBvbkNodW5rKFwi5aSE55CG5ZON5bqU5pe25Ye66ZSZ77yM6K+356iN5ZCO5YaN6K+V44CCXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9uQ29tcGxldGUpIG9uQ29tcGxldGUoKTsgLy8g6YCa55+l5YmN56uv5ZON5bqU5bey5a6M5oiQ77yI5Ye66ZSZ77yJXHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8g5byA5aeL5aSE55CG5rWBXHJcbiAgICBwcm9jZXNzU3RyZWFtKCk7XHJcblxyXG4gICAgLy8g6L+U5Zue5riF55CG5Ye95pWwXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XHJcbiAgICAgIGlmIChvbkNvbXBsZXRlKSBvbkNvbXBsZXRlKCk7IC8vIOehruS/neWPlua2iOivt+axguaXtuS5n+mAmuefpeWujOaIkFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIuivt+axgumUmeivrzpcIiwgZXJyb3IpO1xyXG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwi6K+35rGC6KKr5Lit5patXCIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb25DaHVuayhFUlJPUl9NRVNTQUdFUy5ORVRXT1JLKTtcclxuICAgIH1cclxuICAgIGlmIChvbkNvbXBsZXRlKSBvbkNvbXBsZXRlKCk7IC8vIOmAmuefpeWJjeerr+WTjeW6lOW3suWujOaIkO+8iOWHuumUme+8iVxyXG4gICAgcmV0dXJuICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKTtcclxuICB9XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJFUlJPUl9NRVNTQUdFUyIsIk5FVFdPUksiLCJTRVJWRVIiLCJHRU5FUkFMIiwiU1RSRUFNIiwiQVBJX0tFWV9NSVNTSU5HIiwiQk9UX0lEX01JU1NJTkciLCJQQVJBTUVURVJfRVJST1IiLCJmb3JtYXRNZWRpYUNvbnRlbnQiLCJtZWRpYSIsImxlbmd0aCIsIm1hcCIsIml0ZW0iLCJ0eXBlIiwidG9Mb3dlckNhc2UiLCJ1cmwiLCJzZW5kTWVzc2FnZVRvQ296ZSIsIm1lc3NhZ2UiLCJvbkNodW5rIiwib25Db21wbGV0ZSIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJyZXF1ZXN0Qm9keSIsInVzZXJfaWQiLCJEYXRlIiwibm93IiwibWVzc2FnZXMiLCJyb2xlIiwiY29udGVudCIsInN0cmVhbSIsImNvbnNvbGUiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5Iiwic3RhdHVzIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwib2siLCJlcnJvclRleHQiLCJ0ZXh0IiwiZXJyb3IiLCJhYm9ydCIsInJlYWRlciIsImdldFJlYWRlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsInJlY2VpdmVkQ29udGVudCIsImhhc1JlY2VpdmVkQ29udGVudCIsInByb2Nlc3NTdHJlYW0iLCJpc0RvbmUiLCJkb25lIiwidmFsdWUiLCJyZWFkIiwiY2h1bmsiLCJkZWNvZGUiLCJsaW5lcyIsInNwbGl0IiwiZmlsdGVyIiwibGluZSIsInRyaW0iLCJoYXNQcm9jZXNzZWRWYWxpZERhdGEiLCJzdGFydHNXaXRoIiwianNvblN0ciIsInN1YnN0cmluZyIsImRhdGEiLCJwYXJzZSIsImxhc3RfZXJyb3IiLCJlcnJvck1zZyIsImNvZGUiLCJtc2ciLCJjaG9pY2VzIiwiZGVsdGEiLCJmaW5pc2hfcmVhc29uIiwiZSIsIndhcm4iLCJpbmNsdWRlcyIsIm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/cozeService.ts\n"));

/***/ })

});